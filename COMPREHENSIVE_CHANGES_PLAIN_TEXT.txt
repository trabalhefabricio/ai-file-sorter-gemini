COMPREHENSIVE CHANGES DOCUMENTATION - "I WANT" FORMAT (PLAIN TEXT)

Purpose: This document provides a complete, ordered list of all changes made to this fork compared to the original hyperfield/ai-file-sorter repository. Each change is described in "I want" format suitable for feeding to AI agents for implementation.

Original Repository: https://github.com/hyperfield/ai-file-sorter
This Fork: https://github.com/trabalhefabricio/ai-file-sorter-iconic

Date Created: January 7, 2026
Last Updated: January 7, 2026

================================================================================
TABLE OF CONTENTS
================================================================================

1. Section 1: Changed/Enhanced Features from Original
2. Section 2: Implemented New Features
3. Section 3: Planned/To-Be-Implemented Features

================================================================================
SECTION 1: CHANGED/ENHANCED FEATURES FROM ORIGINAL
================================================================================

These are modifications and enhancements to existing functionality in the original fork.

--------------------------------------------------------------------------------
1.1 WHITELIST SYSTEM - HIERARCHICAL MODE SUPPORT
--------------------------------------------------------------------------------

I want the whitelist system to support TWO distinct operational modes: hierarchical mode and shared mode (classic), allowing users to choose how categories and subcategories are organized.

DETAILED REQUIREMENTS:

- I want the whitelist system to store a use_hierarchical boolean flag for each whitelist entry

- I want hierarchical mode where each category has its own dedicated set of subcategories (e.g., "Code" category has "Python, JavaScript, C++" subcategories, while "Documents" category has "Reports, Invoices, Contracts" subcategories)

- I want shared mode (classic) where all categories share the same global pool of subcategories

- I want the WhitelistStore class to persist both modes in the whitelists.ini file

- I want the system to store hierarchical mappings using category_subcategory_map (std::map<std::string, std::vector<std::string>>) where each category key maps to its specific subcategory vector

- I want the INI file format to include UseHierarchical=true/false for each whitelist

- I want hierarchical subcategories stored as separate keys like Subcategories_Code, Subcategories_Documents, etc. in the INI file

- I want backward compatibility so existing whitelists without the hierarchical flag default to shared mode

- I want the WhitelistManagerDialog to include radio buttons for mode selection with labels "Hierarchical Mode (Each category has its own subcategories)" and "Shared Mode (All categories share subcategories)"

- I want the UI to dynamically show/hide the shared subcategories editor based on selected mode

- I want conversion functionality that allows users to migrate between modes with a confirmation dialog warning about potential data changes

- I want the hierarchical tree view to display categories as parent nodes with their specific subcategories as children in hierarchical mode

- I want the shared subcategories section to only appear in shared mode with a dedicated "Edit Shared Subcategories" button

- I want semicolon (;) as the primary separator for categories and subcategories in the INI file, with fallback to comma (,) for backward compatibility

- I want the join_csv function to use "; " (semicolon with space) when serializing lists to INI format

TECHNICAL IMPLEMENTATION DETAILS:

- Location: app/lib/WhitelistStore.cpp and app/include/WhitelistStore.hpp
- Location: app/lib/WhitelistManagerDialog.cpp and app/include/WhitelistManagerDialog.hpp
- The WhitelistEntry struct must include: bool use_hierarchical and std::map<std::string, std::vector<std::string>> category_subcategory_map
- When loading whitelists, check for UseHierarchical key and populate category_subcategory_map by reading Subcategories_<CategoryName> keys
- When saving in hierarchical mode, write each category's subcategories to its own INI key
- The UI mode switch must trigger on_mode_changed() slot that updates tree display and shows/hides appropriate controls

FILES MODIFIED:
- app/lib/WhitelistStore.cpp (~300 lines)
- app/include/WhitelistStore.hpp
- app/lib/WhitelistManagerDialog.cpp (~500 lines)
- app/include/WhitelistManagerDialog.hpp
- app/lib/WhitelistTreeEditor.cpp (new file, ~400 lines)
- app/include/WhitelistTreeEditor.hpp (new file)

--------------------------------------------------------------------------------
1.2 WHITELIST SYSTEM - SEPARATOR CHANGE FOR CATEGORIES/SUBCATEGORIES
--------------------------------------------------------------------------------

I want the whitelist storage format to use semicolon (;) as the primary separator for categories and subcategories instead of comma (,), while maintaining backward compatibility with existing comma-separated lists.

DETAILED REQUIREMENTS:

- I want the split_csv function to first check for semicolons in the input string and use that as the delimiter if present

- I want comma-based splitting to remain as a fallback for loading old whitelist files

- I want the join_csv function to always output semicolon-separated lists ("; " with space after semicolon)

- I want this change to apply to both Categories and Subcategories fields in the whitelists.ini file

- I want trimming of whitespace from individual items after splitting regardless of delimiter used

- I want empty strings filtered out from the split results

RATIONALE: Semicolons provide clearer visual separation and reduce ambiguity when category names might naturally contain commas (e.g., "Work, Professional Documents" vs "Work; Professional Documents").

TECHNICAL IMPLEMENTATION DETAILS:
- Location: app/lib/WhitelistStore.cpp in anonymous namespace
- The split_csv function checks value.contains(';') first, then falls back to comma splitting
- The join_csv function uses list.join("; ") to create semicolon-separated output
- Both functions handle QString to std::string conversions properly

FILES MODIFIED:
- app/lib/WhitelistStore.cpp (lines 10-43 approximately)

--------------------------------------------------------------------------------
1.3 CATEGORIZATION PROMPT - ENHANCED CONTEXT BUILDING
--------------------------------------------------------------------------------

I want the categorization prompt sent to LLMs to be built from multiple context components in a specific, ordered manner, combining language preferences, whitelist constraints, consistency hints, and user profile information.

DETAILED REQUIREMENTS:

- I want the build_combined_context function to assemble the final context string from multiple sources in this order:
  1. Category language context (if user selected non-English categorization)
  2. Whitelist context (if whitelist is enabled)
  3. Consistency hints (if consistency mode is enabled)
  4. User profile context (if user profiling is enabled) [to be implemented]

- I want each context block separated by double newlines ("\n\n") for clarity

- I want the function to only include non-empty context blocks

- I want build_whitelist_context() to generate a structured text block listing allowed categories and subcategories based on the active whitelist

- I want build_category_language_context() to return language instruction text if user selected a non-English category language (e.g., "Assign categories in Spanish")

- I want format_hint_block() to create consistency hints text showing previous categorization examples from the current session

- I want the context building to be logged at debug level showing the number of categories and subcategories being applied

- I want the final combined context passed to all LLM categorization calls through the consistency_context parameter

RATIONALE: A well-structured context improves LLM categorization accuracy by providing clear constraints, examples, and language preferences without overwhelming the prompt.

TECHNICAL IMPLEMENTATION DETAILS:
- Location: app/lib/CategorizationService.cpp
- Function: std::string build_combined_context(const std::string& hint_block) const
- The function checks settings.get_use_whitelist() before including whitelist block
- Debug logging shows: "Applying category whitelist (X cats, Y subs)"
- Consistency hints are collected via collect_consistency_hints() and formatted via format_hint_block()
- The combined context is built once per file and reused for retries

FILES MODIFIED:
- app/lib/CategorizationService.cpp (lines 516-542 approximately)


--------------------------------------------------------------------------------
1.4 GOOGLE GEMINI API INTEGRATION - COMPLETE IMPLEMENTATION
--------------------------------------------------------------------------------

I want full support for Google Gemini API with intelligent rate limiting, adaptive timeout handling, and free-tier optimization, matching the quality and robustness of the existing OpenAI integration.

DETAILED REQUIREMENTS:

- I want a dedicated GeminiClient class implementing the ILLMClient interface for consistency with other LLM clients

- I want the Select LLM dialog to include a "Google Gemini (Gemini API key)" option alongside Local LLM and ChatGPT options

- I want separate UI fields for Gemini API key and Gemini model name (e.g., "gemini-1.5-flash", "gemini-1.5-pro", "gemini-2.0-flash-exp")

- I want the Settings class to store gemini_api_key and gemini_model separately from OpenAI credentials

- I want intelligent rate limiting at 15 requests per minute (RPM) to respect Gemini's free tier limits

- I want adaptive timeout handling starting at 20 seconds and exponentially increasing up to 240 seconds for slow responses

- I want exponential backoff retry logic with delays of 2s, 4s, 8s, 16s for transient failures (429, 503 errors)

- I want persistent state tracking that saves rate limiter state to avoid quota exhaustion across app restarts

- I want proper error handling for Gemini-specific error codes: 429 (quota exceeded), 503 (service unavailable), 400 (invalid request), 401 (authentication failure)

- I want the GeminiClient to construct proper HTTP requests to https://generativelanguage.googleapis.com/v1beta/models/{model}:generateContent?key={api_key}

- I want request bodies formatted as JSON with contents array containing parts with text fields

- I want response parsing that extracts text from the candidates[0].content.parts[0].text path

- I want graceful handling of safety blocks where Gemini refuses to respond, returning a default "Uncategorized" result

- I want token usage tracking integrated with APIUsageTracker for cost estimation

- I want configuration validation that checks API key format and model name before allowing usage

- I want user-friendly error messages that suggest solutions (e.g., "Check your API key", "Rate limit reached - waiting 60 seconds")

TECHNICAL IMPLEMENTATION DETAILS:
- Location: app/lib/GeminiClient.cpp (~824 lines) and app/include/GeminiClient.hpp
- The class uses libcurl for HTTP requests with proper header setting (Content-Type: application/json, x-goog-api-key: {key})
- Rate limiting uses a token bucket algorithm tracking timestamps of last 15 requests
- Timeout starts at 20s and doubles on timeouts up to 240s maximum
- State file stored at {app_data_dir}/gemini_state.json containing rate limiter timestamps and timeout values
- Response JSON parsed using jsoncpp library
- Error responses include status code, error message, and suggested retry behavior
- Integration with Settings via get_gemini_api_key(), set_gemini_api_key(), get_gemini_model(), set_gemini_model()

FILES MODIFIED/CREATED:
- app/lib/GeminiClient.cpp (NEW, ~824 lines)
- app/include/GeminiClient.hpp (NEW)
- app/lib/Settings.cpp (add Gemini getters/setters)
- app/include/Settings.hpp (add Gemini member variables)
- app/lib/LLMSelectionDialog.cpp (add Gemini UI option)
- app/include/LLMSelectionDialog.hpp (add Gemini UI elements)
- app/lib/CategorizationService.cpp (instantiate GeminiClient when selected)
- CHANGELOG.md (document feature addition in v1.5.0)
- README.md (add "Using your Google Gemini API key" section)

CONFIGURATION FORMAT:
[LLM]
choice=gemini
gemini_api_key=AIzaSy...
gemini_model=gemini-1.5-flash

GEMINI API REQUEST FORMAT (JSON):
{
  "contents": [{
    "parts": [{
      "text": "Categorize this file: document.pdf\n\nAssign a category and subcategory..."
    }]
  }]
}

GEMINI API RESPONSE FORMAT (JSON):
{
  "candidates": [{
    "content": {
      "parts": [{
        "text": "Work Documents : Reports"
      }]
    }
  }]
}

--------------------------------------------------------------------------------
1.5 DRY RUN MODE - ENHANCED PREVIEW DIALOG
--------------------------------------------------------------------------------

I want an enhanced dry run/preview mode that shows a comprehensive From→To table displaying exactly how files will be organized before any actual moves occur, with the ability to toggle dry run on/off and persistent undo support.

DETAILED REQUIREMENTS:

- I want a checkbox labeled "Dry run (preview only, do not move files)" in the results dialog

- I want the preview to show a table with columns: File Name, Current Location (From), New Location (To), Category, Subcategory

- I want the From column to show the abbreviated source path (with ~/ for user home directory)

- I want the To column to show the complete destination path that will be created

- I want the table to support sorting by any column (file name, from, to, category, subcategory)

- I want the table to be read-only during dry run mode - no file movements occur

- I want a clear visual indicator (icon, color, or label) showing when dry run mode is active

- I want the "Confirm & Sort!" button text to change to "Preview Only (Dry Run Active)" when dry run is checked

- I want the button to be disabled or show a warning if user tries to confirm during dry run

- I want users to uncheck dry run and click confirm again to perform actual file movements

- I want the dry run state to be saved so users can close the dialog, review, and come back

- I want the DryRunPreviewDialog class to generate the preview table without touching any files

- I want statistics shown: X files will be moved, Y new folders will be created, Z GB total size

- I want conflict detection during preview (e.g., "file.txt already exists in destination")

- I want the preview to integrate with the existing persistent undo system

RATIONALE: Users need confidence before reorganizing hundreds or thousands of files. A comprehensive preview eliminates anxiety and prevents mistakes.

TECHNICAL IMPLEMENTATION DETAILS:
- Location: app/lib/DryRunPreviewDialog.cpp and app/include/DryRunPreviewDialog.hpp
- Location: app/lib/CategorizationDialog.cpp (dry run checkbox handling)
- The preview dialog uses QTableWidget with 5 columns
- Path abbreviation via Utils::abbreviate_user_path() for From column
- Destination path construction via build_destination_path() for To column
- Statistics calculated by iterating categorized files and summing sizes
- Conflict detection checks if destination file exists using std::filesystem::exists()
- Sorting enabled via table->setSortingEnabled(true)
- Modal dialog blocks until user unchecks dry run or cancels

FILES MODIFIED:
- app/lib/DryRunPreviewDialog.cpp (~300 lines)
- app/include/DryRunPreviewDialog.hpp
- app/lib/CategorizationDialog.cpp (add dry run checkbox and handler)
- app/include/CategorizationDialog.hpp (add dry run state variable)

--------------------------------------------------------------------------------
1.6 PERSISTENT UNDO SYSTEM ENHANCEMENT
--------------------------------------------------------------------------------

I want an enhanced undo system that persists the latest file sorting operation to disk, allowing users to undo their last sort even after closing the application or the categorization dialog, with best-effort restoration that handles conflicts gracefully.

DETAILED REQUIREMENTS:

- I want every successful file sorting operation to save a complete undo plan to disk before moving any files

- I want the undo plan stored as a JSON file containing: original paths, destination paths, timestamps, operation metadata

- I want the undo plan path stored in a SQLite database table undo_history with fields: undo_id, plan_path, description, timestamp, is_undone

- I want the Edit menu to include "Undo Last Run" as the first menu item (before other actions)

- I want "Undo Last Run" to be enabled only when a valid undo plan exists

- I want the UndoManager class to handle plan saving, loading, and execution

- I want undo execution to be best-effort: files that were deleted, modified, or have conflicts are skipped with warnings

- I want a progress dialog during undo showing: "Restoring file X of Y: filename"

- I want undo execution to be atomic: either all non-conflicting files restore or none do

- I want clear user feedback: "Undo completed: X files restored, Y files skipped (conflicts)"

- I want the undo plan marked as is_undone=1 after successful execution to prevent double-undo

- I want the undo plan file deleted after successful undo (optional, configurable)

- I want collision handling: if original location is occupied, skip that file with a logged warning

- I want the system to validate file integrity using stored hashes before undo (optional enhancement)

- I want keyboard shortcut Ctrl+Z (Cmd+Z on macOS) to trigger undo from main window

- I want recent undo operations listed in "Edit → Undo History" submenu (up to 10 most recent)

UNDO PLAN FILE FORMAT (JSON):
{
  "version": "1.0",
  "timestamp": "2026-01-07 18:30:45",
  "operation": "categorize_and_sort",
  "source_folder": "/home/user/Downloads",
  "files": [
    {
      "original_path": "/home/user/Downloads/document.pdf",
      "destination_path": "/home/user/Downloads/Work Documents/Reports/document.pdf",
      "file_size": 245760,
      "checksum": "a1b2c3d4...",
      "category": "Work Documents",
      "subcategory": "Reports"
    }
  ]
}

TECHNICAL IMPLEMENTATION DETAILS:
- Location: app/lib/UndoManager.cpp and app/include/UndoManager.hpp
- Location: app/lib/MainAppEditActions.cpp (Edit menu actions)
- Undo plans stored in {app_data_dir}/undo_plans/undo_{timestamp}.json
- Database table: CREATE TABLE undo_history (undo_id INTEGER PRIMARY KEY AUTOINCREMENT, plan_path TEXT, description TEXT, timestamp DATETIME, is_undone INTEGER DEFAULT 0)
- UndoManager methods: save_undo_plan(), load_latest_undo_plan(), execute_undo(), get_undo_history()
- File restoration uses std::filesystem::rename() with error handling for conflicts
- Progress reported via callback: [UNDO] Restoring: filename (X/Y)
- Keyboard shortcut connected via QAction with QKeySequence::Undo

FILES MODIFIED:
- app/lib/UndoManager.cpp (~400 lines enhancement)
- app/include/UndoManager.hpp
- app/lib/MainAppEditActions.cpp (add undo menu action)
- app/lib/ResultsCoordinator.cpp (save undo plan before sorting)
- app/lib/DatabaseManager.cpp (add undo_history table, CRUD methods)


================================================================================
SECTION 2: IMPLEMENTED NEW FEATURES
================================================================================

These are entirely new features that don't exist in the original fork.

--------------------------------------------------------------------------------
2.1 USER PROFILING & ADAPTIVE LEARNING SYSTEM
--------------------------------------------------------------------------------

I want a comprehensive user profiling system that learns from my file organization patterns over time, builds a detailed user profile, and uses this profile to provide increasingly personalized file categorization suggestions.

DETAILED REQUIREMENTS:

CORE PROFILE BUILDING:
- I want automatic analysis of every folder I organize to extract insights about my interests, work patterns, and organizational style
- I want the system to infer user characteristics from file categories: hobbies (e.g., Music, Photography, Gaming), work patterns (e.g., frequent Document/Report categorization), organizational preferences (minimalist vs detailed)
- I want confidence scores for each characteristic that increase as more evidence accumulates (e.g., Music hobby confidence starts at 0.3 after 3 music files, increases 0.05 per folder with music)
- I want characteristics stored in database table user_profiles with fields: profile_id, profile_name, is_active, created_at, last_updated
- I want detailed characteristics stored in profile_characteristics table with: trait_name, value, confidence, evidence, timestamp
- I want three types of characteristics tracked: Hobbies & Interests, Work & Professional, Organization Style
- I want the system to detect organizational styles: "Minimalist" (<5 categories used), "Balanced" (5-15 categories), "Detailed" (15-25 categories), "Power User" (>25 categories)

FOLDER INSIGHTS TRACKING:
- I want detailed per-folder insights stored including: folder path, analysis date, total files analyzed, dominant categories, category distribution, file type breakdown
- I want folder insights stored in a separate database table linked to user profiles
- I want insights to show which categories dominate each folder (e.g., "Downloads: 60% Downloads, 25% Documents, 15% Media")
- I want temporal tracking showing how folder organization evolves over time
- I want insights used to recommend organization strategies for similar folders

PROFILE-DRIVEN CATEGORIZATION:
- I want the user profile automatically passed to the LLM as context during categorization
- I want the profile context to include: top hobbies (max 5), work domain, organizational style, frequently used categories (max 10)
- I want the profile context formatted as natural language: "User Profile: Primary interests include music production and photography. Organizational style is detailed (20+ categories). Frequently uses: Music, Photos, Work Documents, Code, Archives."
- I want the LLM to use this context to make better categorization decisions aligned with user preferences
- I want profile-based categorization to be toggleable via "Learn from my organization patterns" checkbox on main screen

PER-FOLDER LEARNING CONTROLS:
- I want per-folder learning level configuration: Full, Partial, or None
- I want "Full Learning" (default) to use profile for AI categorization AND store folder insights
- I want "Partial Learning" to skip profile usage but STILL store folder information for future profile building
- I want "No Learning" (None) to completely exclude the folder from profiling - no profile usage, no data storage
- I want a settings icon (⚙️) next to folder path input that opens FolderLearningDialog
- I want the dialog to show: folder path, current learning level (dropdown), explanation of each level, "Save" and "Cancel" buttons
- I want learning level stored in database table folder_learning_settings with fields: folder_path, learning_level, updated_at

PROFILE VISUALIZATION:
- I want a "View User Profile" menu item under Help menu
- I want UserProfileDialog showing three tabs: Overview, Characteristics, Folder Insights
- I want Overview tab showing: profile statistics (total files organized, folders analyzed, confidence level), top characteristics (top 5), organizational style summary
- I want Characteristics tab showing: grouped list by type (Hobbies, Work, Style), each characteristic with name, confidence bar (0-100%), evidence count, last updated timestamp
- I want Folder Insights tab showing: table of analyzed folders with columns (Folder Path, Date, Files, Dominant Category, Distribution %), sortable columns, "Remove" button to delete folder from history
- I want confidence bars color-coded: <40% red, 40-70% yellow, >70% green
- I want tooltips showing evidence examples: "Based on 12 folders containing Music files"

PROFILE EVOLUTION & LEARNING:
- I want characteristic confidence to evolve: new characteristic starts at base confidence (0.3 for hobbies, 0.4 for work), confidence increases by increment per supporting folder (0.05 for hobbies, 0.03 for work), confidence decreases slowly if not reinforced (decay factor)
- I want conflicting evidence handled: if user stops using a category, confidence decreases over time
- I want the system to detect new interests automatically: organizing 3+ folders with new category type triggers new hobby/interest detection
- I want profile resets: "Clear Profile Data" button in profile dialog with confirmation prompt
- I want profile export/import for backup and migration: Export as JSON with all characteristics and folder insights

PRIVACY & CONTROL:
- I want all profile data stored locally in SQLite database - NO cloud storage
- I want clear UI indicators when profile learning is active: checkbox checked on main window, learning level shown next to folder path
- I want complete transparency: users can see exactly what data is collected in profile dialog
- I want easy opt-out: unchecking "Learn from my organization patterns" disables all profile usage but preserves existing data
- I want per-folder granularity: sensitive folders can be set to "None" learning level independently

TECHNICAL IMPLEMENTATION DETAILS:
- Location: app/lib/UserProfileManager.cpp (~657 lines) and app/include/UserProfileManager.hpp
- Location: app/lib/UserProfileDialog.cpp (~400 lines) and app/include/UserProfileDialog.hpp
- Location: app/lib/FolderLearningDialog.cpp (NEW) and app/include/FolderLearningDialog.hpp (NEW)
- Database tables: user_profiles, profile_characteristics, folder_insights, folder_learning_settings
- Integration: UserProfileManager called by CategorizationService after successful categorization
- Profile context injected into LLM prompt via build_profile_context() method
- Confidence calculation constants in anonymous namespace: kMinHobbyConfidence = 0.3f, kConfidenceIncrement = 0.05f, kMinFilesForHobby = 3

DATABASE SCHEMA:
CREATE TABLE user_profiles (
    profile_id INTEGER PRIMARY KEY AUTOINCREMENT,
    profile_name TEXT UNIQUE NOT NULL,
    is_active INTEGER DEFAULT 1,
    created_at DATETIME,
    last_updated DATETIME
);

CREATE TABLE profile_characteristics (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    profile_id INTEGER,
    characteristic_type TEXT,
    trait_name TEXT,
    value TEXT,
    confidence REAL,
    evidence_count INTEGER,
    last_reinforced DATETIME,
    FOREIGN KEY(profile_id) REFERENCES user_profiles(profile_id)
);

CREATE TABLE folder_insights (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    profile_id INTEGER,
    folder_path TEXT,
    analysis_date DATETIME,
    total_files INTEGER,
    dominant_category TEXT,
    category_distribution TEXT,
    file_type_breakdown TEXT,
    FOREIGN KEY(profile_id) REFERENCES user_profiles(profile_id)
);

CREATE TABLE folder_learning_settings (
    folder_path TEXT PRIMARY KEY,
    learning_level TEXT,
    updated_at DATETIME
);

PROFILE CONTEXT EXAMPLE:
User Profile Context:
- Primary interests: Music Production, Photography, Gaming
- Work domain: Software Development
- Organizational style: Detailed (uses 23 categories on average)
- Frequently used categories: Code, Documents, Music, Photos, Downloads, Projects, Archives, Videos, Books, Work Documents
- Profile confidence: 78% (based on 15 folders analyzed)

FILES MODIFIED/CREATED:
- app/lib/UserProfileManager.cpp (NEW, ~657 lines)
- app/include/UserProfileManager.hpp (NEW)
- app/lib/UserProfileDialog.cpp (NEW, ~400 lines)
- app/include/UserProfileDialog.hpp (NEW)
- app/lib/FolderLearningDialog.cpp (NEW, ~200 lines)
- app/include/FolderLearningDialog.hpp (NEW)
- app/lib/DatabaseManager.cpp (add profile tables and CRUD methods)
- app/lib/CategorizationService.cpp (integrate profile context into prompts)
- app/lib/MainApp.cpp (add "Learn from my organization patterns" checkbox, folder settings icon, Help menu item)
- app/lib/MainAppHelpActions.cpp (add "View User Profile" action)
- README.md (add "User Profiling & Adaptive Learning" section)

--------------------------------------------------------------------------------
2.2 DATABASE CACHE MANAGER DIALOG
--------------------------------------------------------------------------------

I want a comprehensive cache management dialog accessible from Settings menu that allows me to view cache statistics, clear cache selectively or completely, optimize the database, and understand cache behavior.

DETAILED REQUIREMENTS:

- I want a menu item "Settings → Manage Cache..." that opens CacheManagerDialog
- I want the dialog to display real-time cache statistics: Total entries count, Total cache size in MB, Oldest entry date, Newest entry date, Cache hit rate (if tracked)
- I want a "Refresh Statistics" button that updates all statistics without closing the dialog
- I want a "Clear All Cache" button with confirmation dialog ("This will delete all X cached categorizations. Continue?")
- I want a "Clear Old Cache" section with a spinbox for days (default 90) and "Clear" button that deletes entries older than specified days
- I want an "Optimize Database" button that runs SQLite VACUUM command to reclaim space and defragment
- I want the optimize operation to show progress: "Optimizing database..." with hourglass cursor
- I want clear feedback after each operation: "Cache cleared: X entries removed", "Database optimized: Y MB reclaimed"
- I want the cache statistics to show the breakdown: X files from cache (hit), Y files from LLM (miss)
- I want folder-specific cache clearing: dropdown to select folder, button to clear cache only for that folder
- I want the dialog to update statistics automatically after any clear operation
- I want all operations to be non-destructive to the database structure - only data is affected
- I want a warning shown if cache is large (>100MB): "Large cache detected. Consider clearing old entries."

TECHNICAL IMPLEMENTATION DETAILS:
- Location: app/lib/CacheManagerDialog.cpp (~212 lines) and app/include/CacheManagerDialog.hpp
- Statistics queries: SELECT COUNT(*) FROM file_categorization, SELECT SUM(length(category) + length(subcategory)) * 0.001 FROM file_categorization for size estimate
- Date queries: SELECT MIN(datetime), MAX(datetime) FROM file_categorization WHERE datetime IS NOT NULL
- Clear operations: DELETE FROM file_categorization WHERE datetime < date('now', '-X days')
- Optimize: db.exec("VACUUM") followed by size comparison
- Modal dialog with QVBoxLayout containing statistics labels, buttons, and result text edit

FILES MODIFIED/CREATED:
- app/lib/CacheManagerDialog.cpp (NEW, ~212 lines)
- app/include/CacheManagerDialog.hpp (NEW)
- app/lib/MainApp.cpp (add Settings menu item)
- app/lib/DatabaseManager.cpp (add get_cache_statistics(), clear_cache_older_than(), optimize_database() methods)

